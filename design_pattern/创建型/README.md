
## 简单工厂：

严格说并不是一个设计模式。简单工厂没有抽象类，只有一个具体工厂类如MyFactory，然后MyFactory里面有个工厂方法CreateProduct返回一个基类产品，具体返回什么具体实例通过传入参数然后用case判断。

用手机生产做个例子：

比如Nokia简单工厂就是只有NokiaFactory工厂类，工厂方法就是CreateNokiaPhone，参数是Nokia手机型号，根据不同型号创建不同的Nokia手机（使用case）。很明显的缺点就是Nokia每发明一个新型号的手机都需要修改简单工厂类（增加case判断），违反了封闭修改，开放扩展原则。


## 工厂方法：
该模式有一个抽象基类和若干个派生的具体工厂类，基类定义了一个虚工厂方法返回指定产品类的基类，派生类需要实现该虚方法并创建具体产品类返回。注意工厂方法的每个具体工厂只负责返回一种产品类。

同样以手机生产做例子：

Nokia工厂方法模式有一个工厂基类NokiaFactory，注意此工厂和上面不一样，是抽象的。该类定义一个虚工厂方法CreateNokiaPhone，该方法返回NokiaPhone基类。然后不同型号的手机对应一个该型号的手机工厂，比如N97Factory，注意此工厂派生于NokiaFactory基类，N97Factory实现虚工厂方法，它返回值是具体的Nokia手机类，如new N97Phone。（注意N97Phone是NokiaPhone的派生类）这样的优点就是，新出一个Nokia手机型号，只需派生一个该型号的工厂而无需修改原来的代码。符合封闭修改，开放扩展原则。


## 抽象工厂：

该模式和工厂方法模式很相似，也是一个抽象基类和若干个具体工厂类，不同的是抽象工厂的工厂基类定义了多个虚工厂方法，每个虚工厂方法负责返回一种产品，多个工厂方法返回多种产品，并且这些产品具有某些联系。

抽象工厂就不止生产Nokia手机了，还生产相关的周边产品，首先NokiaFactory基类会定义两个虚方法，一个是CreateNokiaPhone用来生产手机，另一个是CreateNokiaCharger用于生产对应型号的手机充电器（假定不同型号手机使用不同的充电器）。然后派生类N97Factory就要生产两种相关的产品，一个是N97Phone,还有一个是N97Charger，这两个对象是对应的关系，因此封装到抽象工厂来生产一系列相关的对象。

总结：用最简单的话来概括就是，简单工厂只有一个具体工厂类来创建一种基类的多个不同派生类，工厂方法就是有多个派生于一个基类的具体工厂类，每个具体工厂只生产一种基类的一个派生类，抽象工厂也是只有一个工厂基类，但是每个具体工厂生产多个相关基类的各一个派生类。